diff --git a/driver/unm_nic_ethtool.c b/driver/unm_nic_ethtool.c
index ca1c527..0d4bc0e 100644
--- a/driver/unm_nic_ethtool.c
+++ b/driver/unm_nic_ethtool.c
@@ -1,25 +1,25 @@
 /*
  * Copyright (C) 2003 - 2009 NetXen, Inc.
  * All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston,
  * MA 02111-1307, USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution
  * in the file called LICENSE.
- * 
+ *
  * Contact Information:
  * licensing@netxen.com
  * NetXen, Inc.
@@ -1212,9 +1212,18 @@ static int unm_nic_intr_test(struct net_device *netdev)
 }
 #endif
 
-static int unm_nic_diag_test_count(struct net_device *netdev)
+static int unm_nic_get_sset_count(struct net_device *netdev,
+	int string_set)
 {
 	return UNM_NIC_TEST_LEN;
+	switch(string_set) {
+	case ETH_SS_TEST:
+		return UNM_NIC_TEST_LEN;
+	case ETH_SS_STATS:
+		return UNM_NIC_STATS_LEN;
+	default:
+		return -EOPNOTSUPP;
+	}
 }
 
 static void
@@ -1292,11 +1301,6 @@ unm_nic_get_strings(struct net_device *netdev, uint32_t stringset,
 	}
 }
 
-static int unm_nic_get_stats_count(struct net_device *netdev)
-{
-	return UNM_NIC_STATS_LEN;
-}
-
 /*
  * NOTE: I have displayed only port's stats
  * TBD: unm_nic_stats(struct unm_port * port) doesn't update stats
@@ -1477,7 +1481,7 @@ static int nx_ethtool_get_intr_coalesce(struct net_device *netdev,
 	ethcoal->rx_max_coalesced_frames =
 		adapter->coal.normal.data.rx_packets;
 	ethcoal->tx_max_coalesced_frames =
-		adapter->coal.normal.data.tx_packets;	
+		adapter->coal.normal.data.tx_packets;
 	return 0;
 }
 
@@ -1559,10 +1563,9 @@ static struct ethtool_ops unm_nic_ethtool_ops = {
 	.set_tso                = unm_nic_set_tso,
 #endif
 #endif
-	.self_test_count	= unm_nic_diag_test_count,
 	.self_test		= unm_nic_diag_test,
 	.get_strings		= unm_nic_get_strings,
-	.get_stats_count	= unm_nic_get_stats_count,
+	.get_sset_count		= unm_nic_get_sset_count,
 	.get_ethtool_stats	= unm_nic_get_ethtool_stats,
 	.get_coalesce		= nx_ethtool_get_intr_coalesce,
 	.set_coalesce		= nx_ethtool_set_intr_coalesce,
diff --git a/driver/unm_nic_main.c b/driver/unm_nic_main.c
index 79ab518..bcc3d9b 100644
--- a/driver/unm_nic_main.c
+++ b/driver/unm_nic_main.c
@@ -1,25 +1,25 @@
 /*
  * Copyright (C) 2003 - 2009 NetXen, Inc.
  * All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston,
  * MA 02111-1307, USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution
  * in the file called LICENSE.
- * 
+ *
  * Contact Information:
  * licensing@netxen.com
  * NetXen, Inc.
@@ -815,7 +815,7 @@ nx_rcode_t nx_os_event_wait_setup(nx_dev_handle_t drv_handle,
 				  nx_os_wait_event_t *wait)
 {
 	struct unm_adapter_s *adapter = (struct unm_adapter_s *)drv_handle;
-	uint8_t  comp_id = 0;	
+	uint8_t  comp_id = 0;
 	uint8_t  index   = 0;
 	uint64_t bit_map = 0;
 	uint64_t i       = 0;
@@ -831,7 +831,7 @@ nx_rcode_t nx_os_event_wait_setup(nx_dev_handle_t drv_handle,
 
 		if (!(bit_map & adapter->wait_bit_map[index])) {
 			adapter->wait_bit_map[index] |= bit_map;
-			comp_id = (uint8_t)i;			
+			comp_id = (uint8_t)i;
 			break;
 		}
 	}
@@ -896,7 +896,7 @@ nx_rcode_t nx_os_event_wait(nx_dev_handle_t drv_handle,
 	remove_wait_queue(&wait->wq, &wq_entry);
 #endif
 	list_del(&wait->list);
-	
+
 	return rv;
 }
 
@@ -1565,7 +1565,7 @@ static void cleanup_adapter(struct unm_adapter_s *adapter)
 	}
 #ifdef ESX
 	if(adapter->multi_ctx) {
-		if(adapter->nx_dev != NULL) {	
+		if(adapter->nx_dev != NULL) {
 			if( adapter->nx_dev->saved_rules != NULL)
 				kfree(adapter->nx_dev->saved_rules);
 		}
@@ -1607,7 +1607,7 @@ static void cleanup_adapter(struct unm_adapter_s *adapter)
 		adapter->ahw.db_base = 0UL;
 	}
 
-#if (!defined(ESX) && defined(CONFIG_PCIEAER)) 
+#if (!defined(ESX) && defined(CONFIG_PCIEAER))
 	if (NX_IS_REVISION_P3(adapter->ahw.revision_id))
 		pci_disable_pcie_error_reporting(pdev);
 #endif
@@ -1712,7 +1712,7 @@ static int nx_set_dma_mask(struct unm_adapter_s *adapter, uint8_t revision_id)
 		mask = DMA_BIT_MASK(39);
 		cmask = DMA_BIT_MASK(39);
 		adapter->pci_using_dac = 1;
-	} 
+	}
 #endif
 
 #if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
@@ -1733,7 +1733,7 @@ static void nx_update_dma_mask(unm_adapter *adapter, struct pci_dev *pdev)
 	int shift, change;
 	uint64_t old_mask, mask;
 	int err;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0) 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
 	uint64_t old_cmask;
 #endif
 
@@ -1752,14 +1752,14 @@ static void nx_update_dma_mask(unm_adapter *adapter, struct pci_dev *pdev)
 #endif
 	if (change) {
 		old_mask = pdev->dma_mask;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0) 
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
 		old_cmask = pdev->dev.coherent_dma_mask;
 #endif
 		mask = DMA_BIT_MASK(32+shift);
 		err = pci_set_dma_mask(pdev, mask);
 		if (err)
 			goto err_out;
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)		
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
 		if (NX_IS_REVISION_P3(adapter->ahw.revision_id)) {
 			err = pci_set_consistent_dma_mask(pdev, mask);
 			if (err)
@@ -1772,7 +1772,7 @@ static void nx_update_dma_mask(unm_adapter *adapter, struct pci_dev *pdev)
 	return;
 
 err_out:
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0) 	
+#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,0)
 	err = pci_set_consistent_dma_mask(pdev, old_cmask);
 #endif
 	err = pci_set_dma_mask(pdev, old_mask);
@@ -2049,10 +2049,10 @@ static int nx_enable_msi_x(struct unm_adapter_s *adapter)
 
 	num_msix = pci_enable_msix(adapter->pdev, adapter->msix_entries,
 			    MSIX_ENTRIES_PER_ADAPTER);
-	if (num_msix < 0) 
+	if (num_msix < 0)
 		return (-1);
 	else if (num_msix > 0) {
-		pci_disable_msix(adapter->pdev);		
+		pci_disable_msix(adapter->pdev);
 		return -1;
 	}
 
@@ -2437,7 +2437,7 @@ static int __devinit unm_nic_probe(struct pci_dev *pdev,
 
 	pci_set_master(pdev);
 
-#if (!defined(ESX) && defined(CONFIG_PCIEAER)) 
+#if (!defined(ESX) && defined(CONFIG_PCIEAER))
 	if (NX_IS_REVISION_P3(revision_id))
 		pci_enable_pcie_error_reporting(pdev);
 #endif
@@ -2645,7 +2645,7 @@ static int __devinit unm_nic_probe(struct pci_dev *pdev,
 
 
 	if (db_len == 0) {
-		if(NX_IS_REVISION_P2(revision_id)) {	
+		if(NX_IS_REVISION_P2(revision_id)) {
 			nx_nic_print3(NULL, "doorbell is disabled\n");
 			err = -EIO;
 			goto err_ret;
@@ -2770,7 +2770,7 @@ static int __devinit unm_nic_probe(struct pci_dev *pdev,
 	adapter->watchdog_timer.function = &unm_watchdog_task;
 #endif
 
-	/* Initialize Firmware watchdog  */	
+	/* Initialize Firmware watchdog  */
 	if(adapter->portnum == 0) {
 		init_timer(&adapter->watchdog_timer_fw_reset);
 		adapter->watchdog_timer_fw_reset.data = (unsigned long)adapter;
@@ -2788,7 +2788,7 @@ static int __devinit unm_nic_probe(struct pci_dev *pdev,
 	}
 
 	/* Check flash fw compatiblity. Minimum fw required is 4.0.505 */
-	#define MIN_FLASH_FW_SUPP NX_FW_VERSION(4, 0, 505)	
+	#define MIN_FLASH_FW_SUPP NX_FW_VERSION(4, 0, 505)
 	if (NX_FW_VERSION(adapter->flash_ver.major, adapter->flash_ver.minor,
 	    adapter->flash_ver.sub) < MIN_FLASH_FW_SUPP) {
 		nx_nic_print3(NULL, "Minimum fw version supported is 4.0.505."
@@ -2871,7 +2871,7 @@ static int __devinit unm_nic_probe(struct pci_dev *pdev,
 		goto err_ret;
 	}
 	nx_init_napi(adapter);
-	
+
 #ifdef ESX
 	if (adapter->multi_ctx) {
 		adapter->nx_dev->saved_rules = kmalloc((sizeof(nx_rx_rule_t)*(num_rx_queues + 1))
@@ -2885,7 +2885,7 @@ static int __devinit unm_nic_probe(struct pci_dev *pdev,
 #endif
 
 	if (!unm_nic_fill_adapter_macaddr_from_flash(adapter)) {
-		if (NX_IS_REVISION_P2(revision_id)) {		
+		if (NX_IS_REVISION_P2(revision_id)) {
 			if (adapter->macaddr_set(adapter, adapter->mac_addr) != 0) {
 				err = -EIO;
 				goto err_ret;
@@ -2960,7 +2960,7 @@ static int __devinit unm_nic_probe(struct pci_dev *pdev,
 		nx_nic_print3(NULL, "register_netdev failed\n");
 		goto err_ret;
 	}
-	if(adapter->portnum == 0) {	
+	if(adapter->portnum == 0) {
 		adapter->auto_fw_reset = 1;
 		NXWR32(adapter,UNM_FW_RESET, 0);
 		adapter->fwload_failed_jiffies = jiffies;
@@ -3170,7 +3170,7 @@ static void unm_nic_free_ring_context(struct unm_adapter_s *adapter)
 	if (adapter->nic_net_stats.data != NULL) {
 		pci_free_consistent(adapter->pdev, sizeof (nx_ctx_stats_t),
 				    (void *)adapter->nic_net_stats.data,
-				    adapter->nic_net_stats.phys);	
+				    adapter->nic_net_stats.phys);
 		adapter->nic_net_stats.data = NULL;
 	}
 
@@ -3463,7 +3463,7 @@ static void unm_nic_detach(struct unm_adapter_s *adapter, int ctx_destroy)
 #else
 			wake_up_interruptible(&wait->wq);
 #endif
-		}		
+		}
 	}
 
 	unm_nic_free_ring_context(adapter);
@@ -3601,7 +3601,7 @@ struct napi_struct * nx_nic_multictx_get_napi(struct net_device *netdev , int qu
 	struct unm_adapter_s *adapter = netdev_priv(netdev);
 		if(queue_id < 0 || queue_id > num_rx_queues)
 			return NULL;
-		return &(adapter->host_sds_rings[queue_id].napi);	
+		return &(adapter->host_sds_rings[queue_id].napi);
 }
 #endif
 int nx_nic_multictx_get_ctx_count(struct net_device *netdev, int queue_type)
@@ -3648,7 +3648,7 @@ int nx_nic_multictx_get_queue_vector(struct net_device *netdev, int qid)
 #else
 	return 0;
 #endif
-	
+
 }
 
 int nx_nic_multictx_get_ctx_stats(struct net_device *netdev, int ctx_id,
@@ -3947,7 +3947,7 @@ int nx_nic_multictx_alloc_rx_ctx(struct net_device *netdev)
 		read_lock(&adapter->adapter_lock);
 		unm_nic_enable_all_int(adapter, nxhal_host_rx_ctx);
 		read_unlock(&adapter->adapter_lock);
-		adapter->nx_dev->rx_ctxs_state |= (1 << ctx_id);	
+		adapter->nx_dev->rx_ctxs_state |= (1 << ctx_id);
 		return ctx_id;
 	}
 err_ret:
@@ -4179,7 +4179,7 @@ static void nx_write_rcv_desc_db(struct unm_adapter_s *adapter,
        nx_host_rds_ring_t *nxhal_rds_ring = &nxhal_rx_ctx->rds_rings[ring];
        void* addr;
        ctx_msg msg = {0};
-       	
+
        msg.PegId = UNM_RCV_PEG_DB_ID;
        msg.privId = 1;
        msg.Count = ((nxhal_rds_ring->producer_index - 1) &
@@ -4294,7 +4294,7 @@ static int nx_alloc_sts_rings(struct unm_adapter_s *adapter,
 				STATUS_DESC_RINGSIZE(adapter->MaxRxDescCount),
                                 &nxhal_sds_ring->host_phys,
 				&host_sds_ring->pci_dev);
-		
+
 		if (addr == NULL) {
 			nx_nic_print3(adapter, "Status ring[%d] allocation "
 				      "failed\n", i);
@@ -4356,7 +4356,7 @@ static int nx_alloc_sts_rings(struct unm_adapter_s *adapter,
       error_done:
         nx_free_sts_rings(adapter,nxhal_rx_ctx);
 	return (-ENOMEM);
-	
+
 }
 
 /*
@@ -4418,7 +4418,7 @@ error_done:
 static int nx_unregister_irq(struct unm_adapter_s *adapter,
 			     nx_host_rx_ctx_t *nxhal_host_rx_ctx)
 {
-	
+
 	int i;
 	nx_host_sds_ring_t      *nxhal_sds_ring = NULL;
 	sds_host_ring_t         *host_sds_ring = NULL;
@@ -4674,7 +4674,7 @@ static int unm_nic_new_rx_context_prepare(struct unm_adapter_s *adapter,
 			adapter->ctx_add.ptr    = hostrq.ptr;
 			adapter->ctx_add.phys   = hostrq.phys;
 			adapter->ctx_add.size   = hostrq.size;
-			pci_free_consistent(adapter->pdev, hostrsp.size, hostrsp.ptr, hostrsp.phys);						
+			pci_free_consistent(adapter->pdev, hostrsp.size, hostrsp.ptr, hostrsp.phys);
 		} else {
 			retval = nx_fw_cmd_create_rx_ctx(rx_ctx, &hostrq, &hostrsp);
 			nx_fw_cmd_create_rx_ctx_free_dma(adapter->nx_dev,
@@ -4815,7 +4815,7 @@ static int unm_nic_new_tx_context_prepare(struct unm_adapter_s *adapter)
                     adapter->pexq.qbuf_paddr;
                 tx_ctx->use_pexq = nx_nic_get_pexq_cap(adapter->netdev);
         }
-	
+
 	if (nx_fw_cmd_create_tx_ctx_alloc_dma(adapter->nx_dev, ncds_ring,
 					      &hostrq, &hostrsp) ==
 	    NX_RCODE_SUCCESS) {
@@ -4844,7 +4844,7 @@ static int unm_nic_new_tx_context_prepare(struct unm_adapter_s *adapter)
         }
 	adapter->crb_addr_cmd_producer =
 		UNM_NIC_REG(tx_ctx->cds_ring->host_tx_producer - 0x200);
-	
+
  failure_tx_ctx:
 	return retval;
 }
@@ -4934,7 +4934,7 @@ static void unm_nic_down(struct net_device *netdev)
 
 	if (nx_nic_get_linkevent_cap(adapter))
 		nic_linkevent_request(adapter, 0, 0);
-		
+
 	if (!NX_IS_LSA_REGISTERED(adapter)) {
 
 		read_lock(&adapter->adapter_lock);
@@ -4954,7 +4954,7 @@ static void unm_nic_down(struct net_device *netdev)
 	if (NX_IS_REVISION_P2(adapter->ahw.revision_id)) {
 		nx_nic_p2_stop_port(adapter);
 	}
-	if(!in_atomic()) {	
+	if(!in_atomic()) {
 		if(adapter->is_up == ADAPTER_UP_MAGIC)
 			FLUSH_SCHEDULED_WORK();
 	}
@@ -5063,7 +5063,7 @@ static void nx_nic_p3_set_multi(struct net_device *netdev)
 {
 	struct unm_adapter_s *adapter = netdev_priv(netdev);
 	mac_list_t *cur, *next, *del_list, *add_list = NULL;
-	struct dev_mc_list *mc_ptr;
+	struct netdev_hw_addr *ha;
 	__u8 bcast_addr[ETH_ALEN] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };
 	__uint32_t mode = VPORT_MISS_MODE_DROP;
 
@@ -5087,15 +5087,15 @@ static void nx_nic_p3_set_multi(struct net_device *netdev)
 	}
 
 	if ((netdev->flags & IFF_ALLMULTI) ||
-	    netdev->mc_count > adapter->max_mc_count) {
+	    netdev_mc_count(netdev) > adapter->max_mc_count) {
 		mode = VPORT_MISS_MODE_ACCEPT_MULTI;
 		goto send_fw_cmd;
 	}
 
-	if (netdev->mc_count > 0) {
-		for (mc_ptr = netdev->mc_list; mc_ptr; mc_ptr = mc_ptr->next) {
+	if (netdev_mc_count(netdev) > 0) {
+		netdev_for_each_mc_addr(ha, netdev) {
 
-			nx_nic_p3_add_mac(adapter, mc_ptr->dmi_addr,
+			nx_nic_p3_add_mac(adapter, ha->addr,
 					  &add_list, &del_list);
 		}
 	}
@@ -5125,12 +5125,12 @@ static void nx_nic_p3_set_multi(struct net_device *netdev)
 static void nx_nic_p2_set_multi(struct net_device *netdev)
 {
 	struct unm_adapter_s *adapter = netdev_priv(netdev);
-	struct dev_mc_list *mc_ptr;
+	struct netdev_hw_addr *ha;
 	__u8 null_addr[6] = { 0, 0, 0, 0, 0, 0 };
 	int index = 0;
 
 	if (netdev->flags & IFF_PROMISC ||
-	    netdev->mc_count > adapter->max_mc_count) {
+	    netdev_mc_count(netdev) > adapter->max_mc_count) {
 
 		unm_nic_set_promisc_mode(adapter);
 
@@ -5140,7 +5140,7 @@ static void nx_nic_p2_set_multi(struct net_device *netdev)
 		return;
 	}
 
-	if (netdev->mc_count == 0) {
+	if (netdev_mc_count(netdev) == 0) {
 		unm_nic_unset_promisc_mode(adapter);
 		unm_nic_disable_mcast_filter(adapter);
 		return;
@@ -5149,10 +5149,10 @@ static void nx_nic_p2_set_multi(struct net_device *netdev)
 	unm_nic_set_promisc_mode(adapter);
 	unm_nic_enable_mcast_filter(adapter);
 
-	for (mc_ptr = netdev->mc_list; mc_ptr; mc_ptr = mc_ptr->next, index++)
-		unm_nic_set_mcast_addr(adapter, index, mc_ptr->dmi_addr);
+	netdev_for_each_mc_addr(ha, netdev)
+		unm_nic_set_mcast_addr(adapter, index, ha->addr);
 
-	if (index != netdev->mc_count) {
+	if (index != netdev_mc_count(netdev)) {
 		nx_nic_print4(adapter, "Multicast address count mismatch\n");
 	}
 
@@ -5532,7 +5532,7 @@ int unm_nic_xmit_frame(struct sk_buff *skb, struct net_device *netdev)
 	spin_lock(&adapter->tx_lock);
 	if (!netif_carrier_ok(netdev)) {
 		if (!adapter->testCtx.loopback_start)
-			goto drop_packet;	
+			goto drop_packet;
 	}
 
 	producer = adapter->cmdProducer;
@@ -5848,7 +5848,7 @@ static int unm_nic_check_temp(struct unm_adapter_s *adapter)
 	temp_val = nx_get_temp_val(temp);
 	if (adapter->temp == 0) {
 // initialize value to normal, else if already in warn temp range, no msg comes out
-		adapter->temp = NX_TEMP_NORMAL;  	
+		adapter->temp = NX_TEMP_NORMAL;
 	}
 
 	if (temp_state == NX_TEMP_PANIC) {
@@ -5958,7 +5958,7 @@ int nx_reset_netq_rx_queues( struct net_device *netdev)
 		{
 			ctx_id = nx_nic_multictx_alloc_rx_ctx(netdev);
 			if(ctx_id > 0)
-				nx_nic_multictx_set_rx_rule(netdev, ctx_id, 
+				nx_nic_multictx_set_rx_rule(netdev, ctx_id,
 						(u8 *) (&adapter->nx_dev->saved_rules[ctx_id].arg.m.mac));
 			num_of_queues = num_of_queues & (num_of_queues - 1);
 		}
@@ -5996,7 +5996,7 @@ int netxen_nic_attach_all_ports(struct unm_adapter_s *adapter)
 			continue;
 #else
 	list_for_each_entry(dev,&adapter->pdev->bus->devices,bus_list)  {
-#endif		
+#endif
 		struct net_device *curr_netdev;
 		struct unm_adapter_s *curr_adapter;
 		curr_netdev = pci_get_drvdata(dev);
@@ -6157,7 +6157,7 @@ static void nx_set_dev_ready(struct unm_adapter_s *adapter)
 	api_unlock(adapter);
 }
 
-#if (!defined(ESX) && defined(CONFIG_PCIEAER)) 
+#if (!defined(ESX) && defined(CONFIG_PCIEAER))
 static void nx_clear_aer_state(struct unm_adapter_s *adapter)
 {
 	u32 dev_state;
@@ -6227,7 +6227,7 @@ static int nx_dev_request_reset(struct unm_adapter_s *adapter)
 	dev_state = NXRD32(adapter, UNM_FW_RESET);
 	if (dev_state == NX_NIC_DEV_RESET) {
 		api_unlock(adapter);
-		return 0;	
+		return 0;
 	}
 
 	if (dev_state != NX_NIC_DEV_READY) {
@@ -6316,8 +6316,8 @@ static void unm_watchdog_task_fw_reset(TASK_PARAM adapid)
 				      adapter->fw_alive_failures);
 
 			if (nx_dev_request_reset(adapter))
-				goto out;	
-				
+				goto out;
+
 			failure_type = NXRD32(adapter, UNM_PEG_HALT_STATUS1);
 			return_address = NXRD32(adapter, UNM_PEG_HALT_STATUS2);
 			nx_nic_print3(adapter,"Firmware hang detected. "
@@ -6340,14 +6340,14 @@ static void unm_watchdog_task_fw_reset(TASK_PARAM adapid)
 				nx_nic_print3(adapter,"\nFatal Error.");
                                 nx_nic_print3(adapter,"\nPlease unload and load the driver.\n");
 				nx_set_dev_failed(adapter);
-				goto out2;		
+				goto out2;
 			}
 			else {
 				netxen_nic_detach_all_ports(adapter, 0);
 				rv = netxen_nic_restart_fw(adapter);
 				if(!rv)
 					netxen_nic_attach_all_ports(adapter);
-				
+
 			}
 			nx_set_dev_ready(adapter);
 		}
@@ -6497,7 +6497,7 @@ static int nx_nic_fw40_change_mtu(struct net_device *netdev, int new_mtu)
 				      "max MTU\n");
 			return (-EIO);
 		}
-	} 
+	}
 
 	if ((NXRD32(adapter, UNM_CRB_I2C0 + 0x1c) == NX_SSID_NC375T) &&
 			(new_mtu > 1500)) {
@@ -7255,7 +7255,7 @@ static inline void unm_process_rcv(struct unm_adapter_s *adapter,
 			              "captured offloaded skb %p\n", __FUNCTION__, skb);
 		        kfree_skb(skb);
 		        goto packet_done;
-		}	
+		}
 	}
 	if ((desc->body[0] & NX_PROT_SHIFT_VAL(NX_PROT_MASK)) ==
 	     	NX_PROT_SHIFT_VAL(NX_PROT_NIC_ICMP) &&
@@ -7293,7 +7293,7 @@ static inline void unm_process_rcv(struct unm_adapter_s *adapter,
 
 	if (ret == NET_RX_SUCCESS)
 		adapter->stats.uphappy++;
-	
+
 
 	netdev->last_rx = jiffies;
 #ifndef ESX
@@ -7685,7 +7685,7 @@ static inline void unm_process_lro(struct unm_adapter_s *adapter,
 		lro_adjust_head_skb(head_skb, last_skb, data_length,
 				    &desc->lro_hdr);
 	}
-	
+
 	NX_ADJUST_SMALL_PKT_LEN(head_skb);
 
 	length = head_skb->len;
@@ -7743,7 +7743,7 @@ static int nx_post_rx_descriptors(struct unm_adapter_s *adapter,
 			}
 		}
 
-		list_del(&buffer->link);	
+		list_del(&buffer->link);
 
 		/* make a rcv descriptor  */
 		pdesc = ((rcvDesc_t *) (nxhal_rds_ring->host_addr)) + producer;
@@ -7981,7 +7981,7 @@ unm_process_rcv_ring(struct unm_adapter_s *adapter,
 					 */
 					break;
 				}
-				
+
 				desc->owner = STATUS_OWNER_PHANTOM;
 
 				for (i = 0; i < (cnt - 2); i++) {
@@ -8905,7 +8905,7 @@ static int nx_nic_attach_func(struct pci_dev *pdev)
 }
 
 
-#if (!defined(ESX) && defined(CONFIG_PCIEAER)) 
+#if (!defined(ESX) && defined(CONFIG_PCIEAER))
 static pci_ers_result_t nx_nic_io_error_detected(struct pci_dev *pdev,
 						pci_channel_state_t state)
 {
@@ -8917,7 +8917,7 @@ static pci_ers_result_t nx_nic_io_error_detected(struct pci_dev *pdev,
 
 	if (nx_dev_request_aer(adapter))
 		return PCI_ERS_RESULT_RECOVERED;
-	
+
 	nx_nic_detach_func(adapter);
 
 	pci_disable_device(pdev);
@@ -8976,7 +8976,7 @@ static int unm_nic_resume(struct pci_dev *pdev)
 
 #endif /* (!defined(ESX) && defined(CONFIG_PM)) */
 
-#if (!defined(ESX) && defined(CONFIG_PCIEAER)) 
+#if (!defined(ESX) && defined(CONFIG_PCIEAER))
 static struct pci_error_handlers nx_nic_err_handler = {
 	.error_detected = nx_nic_io_error_detected,
 	.slot_reset = nx_nic_io_slot_reset,
@@ -8993,7 +8993,7 @@ static struct pci_driver unm_driver = {
 	.suspend = unm_nic_suspend,
 	.resume = unm_nic_resume,
 #endif
-#if (!defined(ESX) && defined(CONFIG_PCIEAER)) 
+#if (!defined(ESX) && defined(CONFIG_PCIEAER))
 	.err_handler = &nx_nic_err_handler
 #endif
 
@@ -9021,7 +9021,7 @@ static int __init unm_init_module(void)
 	nx_verify_module_params();
 
 	err = PCI_MODULE_INIT(&unm_driver);
-	
+
 	if (err) {
 
 		unm_cleanup_proc_drv_entries();
diff --git a/nx_xport/nx_pci_xport.c b/nx_xport/nx_pci_xport.c
index 82113e3..ffd97dc 100644
--- a/nx_xport/nx_pci_xport.c
+++ b/nx_xport/nx_pci_xport.c
@@ -1,25 +1,25 @@
 /*
  * Copyright (C) 2003 - 2009 NetXen, Inc.
  * All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston,
  * MA 02111-1307, USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution
  * in the file called LICENSE.
- * 
+ *
  * Contact Information:
  * licensing@netxen.com
  * NetXen, Inc.
@@ -162,7 +162,7 @@ static void unm_pci_release_regions(struct pci_dev *pdev);
 
 static int nx_pci_open(struct inode *inode, struct file *file);
 static int nx_pci_release(struct inode *inode, struct file *file);
-static void nx_sort_adapters(void);	
+static void nx_sort_adapters(void);
 
 /*  PCI Device ID Table  */
 #define NETXEN_PCI_ID(device_id)   PCI_DEVICE(PCI_VENDOR_ID_NX, device_id)
@@ -185,7 +185,7 @@ static struct file_operations unm_pci_fops = {
 	llseek: 	NULL,
 	owner:          THIS_MODULE,
 	open:           nx_pci_open,
-	ioctl:		nx_xport_ioctl,
+	unlocked_ioctl: nx_xport_ioctl,
 	release:	nx_pci_release,
 };
 
@@ -594,7 +594,7 @@ static int __devinit nx_pci_probe(struct pci_dev *pdev,
 	adapter->ahw.device_id = pdev->device;
 	pci_set_drvdata(pdev, adapter);
 
-	adapter->adapter_index = current_adapter_index;	
+	adapter->adapter_index = current_adapter_index;
 	all_adapters[current_adapter_index ++ ] = adapter;
 	return 0;
 
diff --git a/nx_xport/nx_xport.h b/nx_xport/nx_xport.h
index 6faa53c..9a06966 100644
--- a/nx_xport/nx_xport.h
+++ b/nx_xport/nx_xport.h
@@ -1,25 +1,25 @@
 /*
  * Copyright (C) 2003 - 2009 NetXen, Inc.
  * All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston,
  * MA 02111-1307, USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution
  * in the file called LICENSE.
- * 
+ *
  * Contact Information:
  * licensing@netxen.com
  * NetXen, Inc.
@@ -376,8 +376,7 @@ unm_nic_read_w0(unm_adapter * adapter, uint32_t index, uint32_t * value)
 	adapter->unm_nic_hw_read_wx(adapter, index, value, 4);
 }
 
-int nx_xport_ioctl(struct inode *inode, struct file *file,
-              unsigned int cmd, unsigned long u_data);
+long nx_xport_ioctl(struct file *file, unsigned int cmd, unsigned long u_data);
 
 
 /* Functions available from unm_nic_hw.c */
diff --git a/nx_xport/nx_xport_tool.c b/nx_xport/nx_xport_tool.c
index 04507f0..4668e68 100644
--- a/nx_xport/nx_xport_tool.c
+++ b/nx_xport/nx_xport_tool.c
@@ -1,25 +1,25 @@
 /*
  * Copyright (C) 2003 - 2009 NetXen, Inc.
  * All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston,
  * MA 02111-1307, USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution
  * in the file called LICENSE.
- * 
+ *
  * Contact Information:
  * licensing@netxen.com
  * NetXen, Inc.
@@ -29,25 +29,25 @@
 /*
  * Copyright (C) 2003 - 2009 NetXen, Inc.
  * All rights reserved.
- * 
+ *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
  * as published by the Free Software Foundation; either version 2
  * of the License, or (at your option) any later version.
- * 
+ *
  * This program is distributed in the hope that it will be useful, but
  * WITHOUT ANY WARRANTY; without even the implied warranty of
  * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  * GNU General Public License for more details.
- * 
+ *
  * You should have received a copy of the GNU General Public License
  * along with this program; if not, write to the Free Software
  * Foundation, Inc., 59 Temple Place - Suite 330, Boston,
  * MA 02111-1307, USA.
- * 
+ *
  * The full GNU General Public License is included in this distribution
  * in the file called LICENSE.
- * 
+ *
  * Contact Information:
  * licensing@netxen.com
  * NetXen, Inc.
@@ -61,6 +61,7 @@
 #include <asm/types.h>
 #include <asm/uaccess.h>
 #include <linux/kernel.h>
+#include <linux/smp_lock.h>
 
 #include "nx_xport.h"
 #include "nic_phan_reg.h"
@@ -76,7 +77,7 @@ static int nx_xport_do_ioctl(unsigned long u_data)
 	struct unm_adapter_s *adapter = NULL;
 	int retval = 0;
 	uint64_t efuse_chip_id = 0;
-	
+
 	if (copy_from_user(&data, up_data, sizeof(data))) {
 		/* evil user tried to crash the kernel */
 		printk("bad copy from userland: %d\n",
@@ -85,13 +86,13 @@ static int nx_xport_do_ioctl(unsigned long u_data)
 		goto error_out;
 	}
 	adapter = all_adapters[data.rv];
-	
+
 	if(!adapter)
 	{
 		printk("Adapter is NULL\n");
 		retval = -EFAULT;
 		goto error_out;
-	}	
+	}
 
 	/* Shouldn't access beyond legal limits of  "char u[64];" member */
 	if (!data.ptr && (data.size > sizeof(data.u))) {
@@ -202,12 +203,12 @@ static int nx_xport_do_ioctl(unsigned long u_data)
 
 		case UNM_CMD_EFUSE_CHIP_ID:
 
-			efuse_chip_id = 
-				adapter->unm_nic_pci_read_normalize(adapter, 
+			efuse_chip_id =
+				adapter->unm_nic_pci_read_normalize(adapter,
 						UNM_EFUSE_CHIP_ID_HIGH);
 			efuse_chip_id <<= 32;
-			efuse_chip_id |= 
-				adapter->unm_nic_pci_read_normalize(adapter, 
+			efuse_chip_id |=
+				adapter->unm_nic_pci_read_normalize(adapter,
 						UNM_EFUSE_CHIP_ID_LOW);
 			if(copy_to_user((void *) &up_data->u, &efuse_chip_id,
 						sizeof(uint64_t))) {
@@ -256,14 +257,16 @@ error_out:
  * nx_xport_ioctl ()    We provide the tcl/phanmon support through these
  * ioctls.
  */
-int nx_xport_ioctl(struct inode *inode, struct file *file,
-              unsigned int cmd, unsigned long u_data)
+long nx_xport_ioctl(struct file *file, unsigned int cmd, unsigned long u_data)
 {
 	int err = 0;
 
 //        printk("doing ioctl\n");
 
+	lock_kernel();
+
 	if (!capable(CAP_NET_ADMIN))
+		unlock_kernel();
 		return -EPERM;
 
         switch (cmd) {
@@ -276,5 +279,6 @@ int nx_xport_ioctl(struct inode *inode, struct file *file,
 		break;
 	}
 
+	unlock_kernel();
 	return err;
 }
